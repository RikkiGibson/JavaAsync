/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.storage.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.storage.Containers;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.storage.models.ContainerCreateHeaders;
import com.microsoft.azure.storage.models.ContainerDeleteHeaders;
import com.microsoft.azure.storage.models.ContainerGetAclHeaders;
import com.microsoft.azure.storage.models.ContainerGetMetadataHeaders;
import com.microsoft.azure.storage.models.ContainerGetPropertiesHeaders;
import com.microsoft.azure.storage.models.ContainerLeaseHeaders;
import com.microsoft.azure.storage.models.ContainerListBlobsHeaders;
import com.microsoft.azure.storage.models.ContainerSetAclHeaders;
import com.microsoft.azure.storage.models.ContainerSetMetadataHeaders;
import com.microsoft.azure.storage.models.LeaseActionType;
import com.microsoft.azure.storage.models.ListBlobsIncludeType;
import com.microsoft.azure.storage.models.ListBlobsResponse;
import com.microsoft.azure.storage.models.PublicAccessType;
import com.microsoft.azure.storage.models.SignedIdentifier;
import com.microsoft.rest.DateTimeRfc1123;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Containers.
 */
public class ContainersImpl implements Containers {
    /** The Retrofit service to perform REST calls. */
    private ContainersService service;
    /** The service client containing this operation class. */
    private AzureBlobStorageImpl client;

    /**
     * Initializes an instance of Containers.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ContainersImpl(Retrofit retrofit, AzureBlobStorageImpl client) {
        this.service = retrofit.create(ContainersService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Containers to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ContainersService {
        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers create" })
        @PUT("{containerName}")
        Observable<Response<ResponseBody>> create(@Query("timeout") Integer timeout, @Header("x-ms-meta") String metadata, @Header("x-ms-blob-public-access") PublicAccessType access, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers getProperties" })
        @GET("{containerName}")
        Observable<Response<ResponseBody>> getProperties(@Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers delete" })
        @HTTP(path = "{containerName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("If-Modified-Since") DateTimeRfc1123 ifModifiedSince, @Header("If-Unmodified-Since") DateTimeRfc1123 ifUnmodifiedSince, @Header("If-Match") String ifMatches, @Header("If-None-Match") String ifNoneMatch, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers getMetadata" })
        @GET("{containerName}")
        Observable<Response<ResponseBody>> getMetadata(@Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Query("comp") String comp, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers setMetadata" })
        @PUT("{containerName}")
        Observable<Response<ResponseBody>> setMetadata(@Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("x-ms-meta") String metadata, @Header("If-Modified-Since") DateTimeRfc1123 ifModifiedSince, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Query("comp") String comp, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers getAcl" })
        @GET("{containerName}")
        Observable<Response<ResponseBody>> getAcl(@Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Query("comp") String comp, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers setAcl" })
        @PUT("{containerName}")
        Observable<Response<ResponseBody>> setAcl(@Body List<SignedIdentifier> containerAcl, @Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("x-ms-blob-public-access") PublicAccessType access, @Header("If-Modified-Since") DateTimeRfc1123 ifModifiedSince, @Header("If-Unmodified-Since") DateTimeRfc1123 ifUnmodifiedSince, @Header("If-Match") String ifMatches, @Header("If-None-Match") String ifNoneMatch, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Query("comp") String comp, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers lease" })
        @PUT("{containerName}")
        Observable<Response<ResponseBody>> lease(@Query("timeout") Integer timeout, @Header("x-ms-lease-id") String leaseId, @Header("x-ms-lease-action") LeaseActionType action, @Header("x-ms-lease-break-period") Integer breakPeriod, @Header("x-ms-lease-duration") Integer duration, @Header("x-ms-proposed-lease-id") String proposedLeaseId, @Header("If-Modified-Since") DateTimeRfc1123 ifModifiedSince, @Header("If-Unmodified-Since") DateTimeRfc1123 ifUnmodifiedSince, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("comp") String comp, @Query("restype") String restype, @Header("x-ms-parameterized-host") String parameterizedHost);

        @Headers({ "Content-Type: application/xml; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.storage.Containers listBlobs" })
        @GET("{containerName}")
        Observable<Response<ResponseBody>> listBlobs(@Query("prefix") String prefix, @Query("delimiter") String delimiter, @Query("marker") String marker, @Query("maxresults") Integer maxresults, @Query("include") ListBlobsIncludeType include, @Query("timeout") Integer timeout, @Header("x-ms-version") String version, @Header("x-ms-client-request-id") String requestId, @Query("restype") String restype, @Query("comp") String comp, @Header("x-ms-parameterized-host") String parameterizedHost);

    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void create() {
        createWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> createAsync() {
        return createWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerCreateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>> createWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final Integer timeout = null;
        final String metadata = null;
        final PublicAccessType access = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.create(timeout, metadata, access, this.client.version(), requestId, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerCreateHeaders> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void create(Integer timeout, String metadata, PublicAccessType access, String requestId) {
        createWithServiceResponseAsync(timeout, metadata, access, requestId).toBlocking().single().body();
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> createAsync(Integer timeout, String metadata, PublicAccessType access, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createWithServiceResponseAsync(timeout, metadata, access, requestId), serviceCallback);
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> createAsync(Integer timeout, String metadata, PublicAccessType access, String requestId) {
        return createWithServiceResponseAsync(timeout, metadata, access, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerCreateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * creates a new container under the specified account. If the container with the same name already exists, the operation fails.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>> createWithServiceResponseAsync(Integer timeout, String metadata, PublicAccessType access, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.create(timeout, metadata, access, this.client.version(), requestId, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerCreateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerCreateHeaders> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerCreateHeaders> createDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerCreateHeaders.class);
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getProperties() {
        getPropertiesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getPropertiesAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getPropertiesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> getPropertiesAsync() {
        return getPropertiesWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>> getPropertiesWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final Integer timeout = null;
        final String leaseId = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.getProperties(timeout, leaseId, this.client.version(), requestId, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders> clientResponse = getPropertiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getProperties(Integer timeout, String leaseId, String requestId) {
        getPropertiesWithServiceResponseAsync(timeout, leaseId, requestId).toBlocking().single().body();
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getPropertiesAsync(Integer timeout, String leaseId, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getPropertiesWithServiceResponseAsync(timeout, leaseId, requestId), serviceCallback);
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> getPropertiesAsync(Integer timeout, String leaseId, String requestId) {
        return getPropertiesWithServiceResponseAsync(timeout, leaseId, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>> getPropertiesWithServiceResponseAsync(Integer timeout, String leaseId, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.getProperties(timeout, leaseId, this.client.version(), requestId, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders> clientResponse = getPropertiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerGetPropertiesHeaders> getPropertiesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerGetPropertiesHeaders.class);
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete() {
        deleteWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> deleteAsync() {
        return deleteWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerDeleteHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>> deleteWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final Integer timeout = null;
        final String leaseId = null;
        final DateTime ifModifiedSince = null;
        final DateTime ifUnmodifiedSince = null;
        final String ifMatches = null;
        final String ifNoneMatch = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        DateTimeRfc1123 ifUnmodifiedSinceConverted = null;
        if (ifUnmodifiedSince != null) {
            ifUnmodifiedSinceConverted = new DateTimeRfc1123(ifUnmodifiedSince);
        }
        return service.delete(timeout, leaseId, ifModifiedSinceConverted, ifUnmodifiedSinceConverted, ifMatches, ifNoneMatch, this.client.version(), requestId, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerDeleteHeaders> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(Integer timeout, String leaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId) {
        deleteWithServiceResponseAsync(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatches, ifNoneMatch, requestId).toBlocking().single().body();
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(Integer timeout, String leaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteWithServiceResponseAsync(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatches, ifNoneMatch, requestId), serviceCallback);
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> deleteAsync(Integer timeout, String leaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId) {
        return deleteWithServiceResponseAsync(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatches, ifNoneMatch, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerDeleteHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>> deleteWithServiceResponseAsync(Integer timeout, String leaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        DateTimeRfc1123 ifUnmodifiedSinceConverted = null;
        if (ifUnmodifiedSince != null) {
            ifUnmodifiedSinceConverted = new DateTimeRfc1123(ifUnmodifiedSince);
        }
        return service.delete(timeout, leaseId, ifModifiedSinceConverted, ifUnmodifiedSinceConverted, ifMatches, ifNoneMatch, this.client.version(), requestId, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerDeleteHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerDeleteHeaders> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerDeleteHeaders> deleteDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerDeleteHeaders.class);
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getMetadata() {
        getMetadataWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getMetadataAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getMetadataWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> getMetadataAsync() {
        return getMetadataWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>> getMetadataWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "metadata";
        final Integer timeout = null;
        final String leaseId = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.getMetadata(timeout, leaseId, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders> clientResponse = getMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void getMetadata(Integer timeout, String leaseId, String requestId) {
        getMetadataWithServiceResponseAsync(timeout, leaseId, requestId).toBlocking().single().body();
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> getMetadataAsync(Integer timeout, String leaseId, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getMetadataWithServiceResponseAsync(timeout, leaseId, requestId), serviceCallback);
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> getMetadataAsync(Integer timeout, String leaseId, String requestId) {
        return getMetadataWithServiceResponseAsync(timeout, leaseId, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * returns all user-defined metadata for the container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>> getMetadataWithServiceResponseAsync(Integer timeout, String leaseId, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "metadata";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.getMetadata(timeout, leaseId, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders> clientResponse = getMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerGetMetadataHeaders> getMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerGetMetadataHeaders.class);
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void setMetadata() {
        setMetadataWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> setMetadataAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(setMetadataWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> setMetadataAsync() {
        return setMetadataWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>> setMetadataWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "metadata";
        final Integer timeout = null;
        final String leaseId = null;
        final String metadata = null;
        final DateTime ifModifiedSince = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        return service.setMetadata(timeout, leaseId, metadata, ifModifiedSinceConverted, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders> clientResponse = setMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void setMetadata(Integer timeout, String leaseId, String metadata, DateTime ifModifiedSince, String requestId) {
        setMetadataWithServiceResponseAsync(timeout, leaseId, metadata, ifModifiedSince, requestId).toBlocking().single().body();
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> setMetadataAsync(Integer timeout, String leaseId, String metadata, DateTime ifModifiedSince, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(setMetadataWithServiceResponseAsync(timeout, leaseId, metadata, ifModifiedSince, requestId), serviceCallback);
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> setMetadataAsync(Integer timeout, String leaseId, String metadata, DateTime ifModifiedSince, String requestId) {
        return setMetadataWithServiceResponseAsync(timeout, leaseId, metadata, ifModifiedSince, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param metadata Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>> setMetadataWithServiceResponseAsync(Integer timeout, String leaseId, String metadata, DateTime ifModifiedSince, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "metadata";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        return service.setMetadata(timeout, leaseId, metadata, ifModifiedSinceConverted, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders> clientResponse = setMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerSetMetadataHeaders> setMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerSetMetadataHeaders.class);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SignedIdentifier&gt; object if successful.
     */
    public List<SignedIdentifier> getAcl() {
        return getAclWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SignedIdentifier>> getAclAsync(final ServiceCallback<List<SignedIdentifier>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAclWithServiceResponseAsync(), serviceCallback);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SignedIdentifier&gt; object
     */
    public Observable<List<SignedIdentifier>> getAclAsync() {
        return getAclWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>, List<SignedIdentifier>>() {
            @Override
            public List<SignedIdentifier> call(ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SignedIdentifier&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>> getAclWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "acl";
        final Integer timeout = null;
        final String leaseId = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.getAcl(timeout, leaseId, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders> clientResponse = getAclDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SignedIdentifier&gt; object if successful.
     */
    public List<SignedIdentifier> getAcl(Integer timeout, String leaseId, String requestId) {
        return getAclWithServiceResponseAsync(timeout, leaseId, requestId).toBlocking().single().body();
    }

    /**
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SignedIdentifier>> getAclAsync(Integer timeout, String leaseId, String requestId, final ServiceCallback<List<SignedIdentifier>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAclWithServiceResponseAsync(timeout, leaseId, requestId), serviceCallback);
    }

    /**
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SignedIdentifier&gt; object
     */
    public Observable<List<SignedIdentifier>> getAclAsync(Integer timeout, String leaseId, String requestId) {
        return getAclWithServiceResponseAsync(timeout, leaseId, requestId).map(new Func1<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>, List<SignedIdentifier>>() {
            @Override
            public List<SignedIdentifier> call(ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SignedIdentifier&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>> getAclWithServiceResponseAsync(Integer timeout, String leaseId, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "acl";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.getAcl(timeout, leaseId, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders> clientResponse = getAclDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<SignedIdentifier>, ContainerGetAclHeaders> getAclDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<SignedIdentifier>, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<SignedIdentifier>>() { }.getType())
                .buildWithHeaders(response, ContainerGetAclHeaders.class);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void setAcl() {
        setAclWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> setAclAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(setAclWithServiceResponseAsync(), serviceCallback);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> setAclAsync() {
        return setAclWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerSetAclHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>> setAclWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "acl";
        final List<SignedIdentifier> containerAcl = null;
        final Integer timeout = null;
        final String leaseId = null;
        final PublicAccessType access = null;
        final DateTime ifModifiedSince = null;
        final DateTime ifUnmodifiedSince = null;
        final String ifMatches = null;
        final String ifNoneMatch = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        DateTimeRfc1123 ifUnmodifiedSinceConverted = null;
        if (ifUnmodifiedSince != null) {
            ifUnmodifiedSinceConverted = new DateTimeRfc1123(ifUnmodifiedSince);
        }
        return service.setAcl(containerAcl, timeout, leaseId, access, ifModifiedSinceConverted, ifUnmodifiedSinceConverted, ifMatches, ifNoneMatch, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerSetAclHeaders> clientResponse = setAclDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param containerAcl the acls for the container
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void setAcl(List<SignedIdentifier> containerAcl, Integer timeout, String leaseId, PublicAccessType access, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId) {
        setAclWithServiceResponseAsync(containerAcl, timeout, leaseId, access, ifModifiedSince, ifUnmodifiedSince, ifMatches, ifNoneMatch, requestId).toBlocking().single().body();
    }

    /**
     *
     * @param containerAcl the acls for the container
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> setAclAsync(List<SignedIdentifier> containerAcl, Integer timeout, String leaseId, PublicAccessType access, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(setAclWithServiceResponseAsync(containerAcl, timeout, leaseId, access, ifModifiedSince, ifUnmodifiedSince, ifMatches, ifNoneMatch, requestId), serviceCallback);
    }

    /**
     *
     * @param containerAcl the acls for the container
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> setAclAsync(List<SignedIdentifier> containerAcl, Integer timeout, String leaseId, PublicAccessType access, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId) {
        return setAclWithServiceResponseAsync(containerAcl, timeout, leaseId, access, ifModifiedSince, ifUnmodifiedSince, ifMatches, ifNoneMatch, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerSetAclHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param containerAcl the acls for the container
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param access Specifies whether data in the container may be accessed publicly and the level of access. Possible values include: 'container', 'blob'
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param ifMatches Specify an ETag value to operate only on blobs with a matching value.
     * @param ifNoneMatch Specify an ETag value to operate only on blobs without a matching value.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>> setAclWithServiceResponseAsync(List<SignedIdentifier> containerAcl, Integer timeout, String leaseId, PublicAccessType access, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String ifMatches, String ifNoneMatch, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        Validator.validate(containerAcl);
        final String restype = "container";
        final String comp = "acl";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        DateTimeRfc1123 ifUnmodifiedSinceConverted = null;
        if (ifUnmodifiedSince != null) {
            ifUnmodifiedSinceConverted = new DateTimeRfc1123(ifUnmodifiedSince);
        }
        return service.setAcl(containerAcl, timeout, leaseId, access, ifModifiedSinceConverted, ifUnmodifiedSinceConverted, ifMatches, ifNoneMatch, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerSetAclHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerSetAclHeaders> clientResponse = setAclDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerSetAclHeaders> setAclDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerSetAclHeaders.class);
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void lease(LeaseActionType action) {
        leaseWithServiceResponseAsync(action).toBlocking().single().body();
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> leaseAsync(LeaseActionType action, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(leaseWithServiceResponseAsync(action), serviceCallback);
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> leaseAsync(LeaseActionType action) {
        return leaseWithServiceResponseAsync(action).map(new Func1<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerLeaseHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>> leaseWithServiceResponseAsync(LeaseActionType action) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (action == null) {
            throw new IllegalArgumentException("Parameter action is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String comp = "lease";
        final String restype = "container";
        final Integer timeout = null;
        final String leaseId = null;
        final Integer breakPeriod = null;
        final Integer duration = null;
        final String proposedLeaseId = null;
        final DateTime ifModifiedSince = null;
        final DateTime ifUnmodifiedSince = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        DateTimeRfc1123 ifUnmodifiedSinceConverted = null;
        if (ifUnmodifiedSince != null) {
            ifUnmodifiedSinceConverted = new DateTimeRfc1123(ifUnmodifiedSince);
        }
        return service.lease(timeout, leaseId, action, breakPeriod, duration, proposedLeaseId, ifModifiedSinceConverted, ifUnmodifiedSinceConverted, this.client.version(), requestId, comp, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerLeaseHeaders> clientResponse = leaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param breakPeriod For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.
     * @param duration Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.
     * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void lease(LeaseActionType action, Integer timeout, String leaseId, Integer breakPeriod, Integer duration, String proposedLeaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String requestId) {
        leaseWithServiceResponseAsync(action, timeout, leaseId, breakPeriod, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince, requestId).toBlocking().single().body();
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param breakPeriod For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.
     * @param duration Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.
     * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> leaseAsync(LeaseActionType action, Integer timeout, String leaseId, Integer breakPeriod, Integer duration, String proposedLeaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String requestId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(leaseWithServiceResponseAsync(action, timeout, leaseId, breakPeriod, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince, requestId), serviceCallback);
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param breakPeriod For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.
     * @param duration Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.
     * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> leaseAsync(LeaseActionType action, Integer timeout, String leaseId, Integer breakPeriod, Integer duration, String proposedLeaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String requestId) {
        return leaseWithServiceResponseAsync(action, timeout, leaseId, breakPeriod, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince, requestId).map(new Func1<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, ContainerLeaseHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
     *
     * @param action Describes what lease action to take. Possible values include: 'acquire', 'renew', 'change', 'release', 'break'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param leaseId If specified, the operation only succeeds if the container's lease is active and matches this ID.
     * @param breakPeriod For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.
     * @param duration Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.
     * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.
     * @param ifModifiedSince Specify this header value to operate only on a blob if it has been modified since the specified date/time.
     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>> leaseWithServiceResponseAsync(LeaseActionType action, Integer timeout, String leaseId, Integer breakPeriod, Integer duration, String proposedLeaseId, DateTime ifModifiedSince, DateTime ifUnmodifiedSince, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (action == null) {
            throw new IllegalArgumentException("Parameter action is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String comp = "lease";
        final String restype = "container";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        DateTimeRfc1123 ifModifiedSinceConverted = null;
        if (ifModifiedSince != null) {
            ifModifiedSinceConverted = new DateTimeRfc1123(ifModifiedSince);
        }
        DateTimeRfc1123 ifUnmodifiedSinceConverted = null;
        if (ifUnmodifiedSince != null) {
            ifUnmodifiedSinceConverted = new DateTimeRfc1123(ifUnmodifiedSince);
        }
        return service.lease(timeout, leaseId, action, breakPeriod, duration, proposedLeaseId, ifModifiedSinceConverted, ifUnmodifiedSinceConverted, this.client.version(), requestId, comp, restype, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, ContainerLeaseHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, ContainerLeaseHeaders> clientResponse = leaseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, ContainerLeaseHeaders> leaseDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(201, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ContainerLeaseHeaders.class);
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListBlobsResponse object if successful.
     */
    public ListBlobsResponse listBlobs() {
        return listBlobsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListBlobsResponse> listBlobsAsync(final ServiceCallback<ListBlobsResponse> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(listBlobsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListBlobsResponse object
     */
    public Observable<ListBlobsResponse> listBlobsAsync() {
        return listBlobsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>, ListBlobsResponse>() {
            @Override
            public ListBlobsResponse call(ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListBlobsResponse object
     */
    public Observable<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>> listBlobsWithServiceResponseAsync() {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "list";
        final String prefix = null;
        final String delimiter = null;
        final String marker = null;
        final Integer maxresults = null;
        final ListBlobsIncludeType include = null;
        final Integer timeout = null;
        final String requestId = null;
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.listBlobs(prefix, delimiter, marker, maxresults, include, timeout, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders> clientResponse = listBlobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @param prefix Filters the results to return only containers whose name begins with the specified prefix.
     * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix element in the response body that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.
     * @param marker A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.
     * @param maxresults Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.
     * @param include Include this parameter to specify one or more datasets to include in the response. Possible values include: 'snapshots', 'metadata', 'uncommittedblobs', 'copy'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ListBlobsResponse object if successful.
     */
    public ListBlobsResponse listBlobs(String prefix, String delimiter, String marker, Integer maxresults, ListBlobsIncludeType include, Integer timeout, String requestId) {
        return listBlobsWithServiceResponseAsync(prefix, delimiter, marker, maxresults, include, timeout, requestId).toBlocking().single().body();
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @param prefix Filters the results to return only containers whose name begins with the specified prefix.
     * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix element in the response body that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.
     * @param marker A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.
     * @param maxresults Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.
     * @param include Include this parameter to specify one or more datasets to include in the response. Possible values include: 'snapshots', 'metadata', 'uncommittedblobs', 'copy'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ListBlobsResponse> listBlobsAsync(String prefix, String delimiter, String marker, Integer maxresults, ListBlobsIncludeType include, Integer timeout, String requestId, final ServiceCallback<ListBlobsResponse> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(listBlobsWithServiceResponseAsync(prefix, delimiter, marker, maxresults, include, timeout, requestId), serviceCallback);
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @param prefix Filters the results to return only containers whose name begins with the specified prefix.
     * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix element in the response body that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.
     * @param marker A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.
     * @param maxresults Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.
     * @param include Include this parameter to specify one or more datasets to include in the response. Possible values include: 'snapshots', 'metadata', 'uncommittedblobs', 'copy'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListBlobsResponse object
     */
    public Observable<ListBlobsResponse> listBlobsAsync(String prefix, String delimiter, String marker, Integer maxresults, ListBlobsIncludeType include, Integer timeout, String requestId) {
        return listBlobsWithServiceResponseAsync(prefix, delimiter, marker, maxresults, include, timeout, requestId).map(new Func1<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>, ListBlobsResponse>() {
            @Override
            public ListBlobsResponse call(ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * The List Blobs operation returns a list of the blobs under the specified container.
     *
     * @param prefix Filters the results to return only containers whose name begins with the specified prefix.
     * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix element in the response body that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.
     * @param marker A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.
     * @param maxresults Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.
     * @param include Include this parameter to specify one or more datasets to include in the response. Possible values include: 'snapshots', 'metadata', 'uncommittedblobs', 'copy'
     * @param timeout The timeout parameter is expressed in seconds. For more information, see &lt;a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;
     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ListBlobsResponse object
     */
    public Observable<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>> listBlobsWithServiceResponseAsync(String prefix, String delimiter, String marker, Integer maxresults, ListBlobsIncludeType include, Integer timeout, String requestId) {
        if (this.client.accountUrl() == null) {
            throw new IllegalArgumentException("Parameter this.client.accountUrl() is required and cannot be null.");
        }
        if (this.client.version() == null) {
            throw new IllegalArgumentException("Parameter this.client.version() is required and cannot be null.");
        }
        final String restype = "container";
        final String comp = "list";
        String parameterizedHost = Joiner.on(", ").join("{accountUrl}", this.client.accountUrl());
        return service.listBlobs(prefix, delimiter, marker, maxresults, include, timeout, this.client.version(), requestId, restype, comp, parameterizedHost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders> clientResponse = listBlobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<ListBlobsResponse, ContainerListBlobsHeaders> listBlobsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ListBlobsResponse, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ListBlobsResponse>() { }.getType())
                .buildWithHeaders(response, ContainerListBlobsHeaders.class);
    }

}
